

| Sorting Algorithm  | Time Complexity (Best)  | Time Complexity (Average) | Time Complexity (Worst) | Space Complexity | Stable |
|--------------------|-------------------------|---------------------------|-------------------------|------------------|--------|
| Bubble Sort        | O(n)                    | O(n^2)                    | O(n^2)                  | O(1)             | Yes    |
| Insertion Sort     | O(n)                    | O(n^2)                    | O(n^2)                  | O(1)             | Yes    |
| Selection Sort     | O(n^2)                  | O(n^2)                    | O(n^2)                  | O(1)             | No     |
| Merge Sort         | O(n log n)              | O(n log n)                | O(n log n)              | O(n)             | Yes    |
| Quick Sort         | O(n log n)              | O(n log n)                | O(n^2)                  | O(log n)         | No     |
| Heap Sort          | O(n log n)              | O(n log n)                | O(n log n)              | O(1)             | No     |
| Counting Sort      | O(n + k)                | O(n + k)                  | O(n + k)                | O(k)             | Yes    |
| Radix Sort         | O(nk)                   | O(nk)                     | O(nk)                   | O(n + k)         | Yes    |
| Bucket Sort        | O(n + k)                | O(n + k)                  | O(n^2)                  | O(n)             | Yes    |
| Shell Sort         | O(n log n)              | O(n(log n)^2)             | O(n(log n)^2)           | O(1)             | No     |
| Tim Sort           | O(n)                    | O(n log n)                | O(n log n)              | O(n)             | Yes    |

### Explanation

- **Bubble Sort**: Compares adjacent elements and swaps them if they are in the wrong order. Repeats this process until the array is sorted.
- **Insertion Sort**: Builds the sorted array one element at a time by repeatedly inserting the next element into the correct position.
- **Selection Sort**: Repeatedly selects the smallest (or largest) element from the unsorted part and swaps it with the first     unsorted element.
- **Merge Sort**: Divides the array into halves, recursively sorts each half, and then merges the sorted halves.
- **Quick Sort**: Selects a "pivot" element, partitions the array around the pivot, and recursively sorts the partitions.
- **Heap Sort**: Builds a heap from the array, then repeatedly extracts the maximum element from the heap and rebuilds the heap.
- **Counting Sort**: Counts the occurrences of each element and uses this information to place elements in the correct position.
- **Radix Sort**: Sorts elements by processing individual digits. Uses a stable counting sort as a subroutine.
- **Bucket Sort**: Distributes elements into several "buckets," sorts each bucket individually, and then concatenates the sorted buckets.
- **Shell Sort**: A variation of insertion sort that allows the exchange of far-apart elements to reduce large inversions.
- **Tim Sort**: A hybrid sorting algorithm derived from merge sort and insertion sort, used in Python's built-in sort.

### Notes

- **Stability**: A sorting algorithm is stable if it maintains the relative order of equal elements.
- **Time Complexity**: 
  - **Best Case**: The complexity when the input is already sorted or nearly sorted.
  - **Average Case**: The expected complexity for a typical input.
  - **Worst Case**: The complexity for the worst possible input.
- **Space Complexity**: The additional memory used by the algorithm aside from the input array.

This table provides a quick reference to the characteristics of different sorting algorithms, helping in selecting the appropriate algorithm for a specific scenario.

If you have any further questions or need more details, feel free to ask!